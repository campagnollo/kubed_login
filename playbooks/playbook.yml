# playbook.yml
- name: Build & run Podman locally
  hosts: localhost
  connection: local
  gather_facts: false
  collections:
    - containers.podman

  vars_files:
    - clusters-trunc.yml   # must define a top-level "clusters:" list

  tasks:
    - name: Build images in parallel
      containers.podman.podman_image:
        name: "{{ item.name }}"
        tag: latest
        path: "{{ playbook_dir }}/apps/sshd"
        build:
          file: Dockerfile
      loop: "{{ clusters }}"
      loop_control:
        label: "{{ item.name }}"
      async: 7200          # max seconds to allow each build
      poll: 0              # don't wait; fire-and-forget
      register: build_jobs
      tags: [ up ]

    - name: Wait for builds to finish
      ansible.builtin.async_status:
        jid: "{{ item.ansible_job_id }}"
      register: build_wait
      until: build_wait.finished
      retries: 120         # 120 * 5s = 10 minutes max per job; adjust as needed
      delay: 5
      loop: "{{ build_jobs.results }}"
      loop_control:
        label: "{{ item.item.name }}"
      tags: [ up ]

    - name: Run container with SSH per cluster
      containers.podman.podman_container:
        name: "{{ item.name }}"
        image: "{{ item.name }}:latest"
        state: started
        recreate: true
        ports:
          - "{{ 2200 + loop.index0 }}:22"      # host 2200,2201,... -> container 22
        env:
          TZ: UTC
        memory: "256m"        # hard memory limit
        memory_swap: ".25g"     # total memory+swap available
        cpus: 0.05             # limit to half a CPU
        cpu_shares: 128       # relative weight (default 1024)
      loop: "{{ clusters }}"
      loop_control:
        label: "{{ item.name }}"
      tags: [up]

    - name: Tear down containers
      containers.podman.podman_container:
        name: "{{ item.name }}"
        state: absent
      loop: "{{ clusters }}"
      loop_control:
        label: "{{ item.name }}"
      tags: [down]
